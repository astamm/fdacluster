% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kma.R
\name{kma}
\alias{kma}
\title{K-mean alignment and variants for functional data}
\usage{
kma(
  x,
  y,
  n_clusters = 1L,
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  seeds = NULL,
  maximum_number_of_iterations = 100L,
  centroid_type = c("mean", "medoid"),
  distance = c("l2", "pearson"),
  warping_options = c(0.15, 0.15),
  number_of_threads = 1L,
  parallel_method = 0L,
  distance_relative_tolerance = 0.001,
  use_fence = FALSE,
  check_total_dissimilarity = TRUE,
  use_verbose = TRUE,
  compute_overall_center = FALSE
)
}
\arguments{
\item{x}{A numeric matrix of shape \verb{nObs x nPts} specifying the evaluation
grid of each observation.}

\item{y}{A numeric array of shape \verb{nObs x nDim x nPts} specifying the
observation values.}

\item{n_clusters}{An integer value specifying the number of clusters.
Defaults to \code{1L}.}

\item{warping_class}{A string specifying the warping class Choices are
\code{"affine"}, \code{"dilation"}, \code{"none"}, \code{"shift"} or \code{"srsf"}. Defaults to
\code{"affine"}. The SRSF class is the only class which is boundary-preserving.}

\item{seeds}{An integer vector of length \code{n_clust} specifying the indices of
the initial templates. Defaults to \code{NULL}, which boils down to randomly
sampled indices.}

\item{maximum_number_of_iterations}{An integer specifying the maximum number
of iterations before the algorithm stops (default: 100L).}

\item{centroid_type}{A string specifying the type of centroid to compute.
Choices are \code{"mean"} or \code{"medoid"}. Defaults to \code{"mean"}. This is used only
when \code{warping_class != "srsf"}. When \verb{warping_class = "srsf}, the mean is
systematically used.}

\item{distance}{A string specifying the distance used to compare curves.
Choices are \code{"l2"} or \code{"pearson"}. Defaults to \code{"l2"}. This is used only
when \code{warping_class != "srsf"}.}

\item{warping_options}{A numeric vector supplied as a helper to the chosen
\code{warping_class} to decide on warping parameter bounds. This is used only
when \code{warping_class != "srsf"}.}

\item{number_of_threads}{An integer value specifying the number of threads
used for parallelization. Defaults to \code{1L}. This is used only when
\code{warping_class != "srsf"}.}

\item{parallel_method}{An integer value specifying the type of desired
parallelization for template computation, If \code{0L}, templates are computed
in parallel. If \code{1L}, parallelization occurs within a single template
computation (only for the medoid method as of now). Defaults to \code{0L}. This
is used only when \code{warping_class != "srsf"}.}

\item{distance_relative_tolerance}{A numeric value specifying a relative
tolerance on the distance update between two iterations. If all
observations have not sufficiently improved in that sense, the algorithm
stops. Defaults to \code{1e-3}. This is used only when \code{warping_class != "srsf"}.}

\item{use_fence}{A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to \code{FALSE}. This
is used only when \code{warping_class != "srsf"}.}

\item{check_total_dissimilarity}{A boolean specifying whether an additional
stopping criterion based on improvement of the total dissimilarity should
be used. Defaults to \code{TRUE}. This is used only when \code{warping_class != "srsf"}.}

\item{use_verbose}{A boolean specifying whether the algorithm should output
details of the steps to the console. Defaults to \code{TRUE}. This is used only
when \code{warping_class != "srsf"}.}

\item{compute_overall_center}{A boolean specifying whether the overall center
should be also computed. Defaults to \code{FALSE}. This is used only when
\code{warping_class != "srsf"}.}
}
\value{
An object of class \code{kma}, which is a list with the following
components:

\code{original_curves}: A numeric matrix of shape \eqn{N \times L \times M}
storing the original sample of \eqn{N} \eqn{L}-dimensional curves observed
on grids of size \eqn{M}.
\code{original_grids}: A numeric matrix of shape \eqn{N \times M} storing the
original grids of size \eqn{M} on which wer evaluated the \eqn{N} curves;

\code{x}: As input;
\code{y}: As input;
\code{seeds}: Indices used in the algorithm;
\code{iterations}: Number of iterations before the KMA algorithm stops;
\code{n_clust}: As input;
\code{overall_center_grid}: Overall center grid if \code{compute_overall_center} is set;
\code{overall_center_values}: Overall center values if \code{compute_overall_center} is set;
\code{distances_to_overall_center}: Distances of each observation to the overall center if \code{compute_overall_center} is set;
\code{x_final}: Aligned observation grids;
\code{n_clust_final}: Final number of clusters. Note that \code{n_clust_final} may differ from initial number of clusters \code{n_clust} if some clusters are empty;
\code{x_centers_final}: Final center grids;
\code{y_centers_final}: Final center values;
\code{template_grids}: List of template grids at each iteration;
\code{template_values}: List of template values at each iteration;
\code{labels}: Cluster memberships;
\code{final_dissimilarity}: Distances of each observation to the center of its assigned cluster;
\code{parameters_list}: List of estimated warping parameters at each iteration;
\code{parameters}: Final estimated warping parameters;
\code{warping_method}: As input;
\code{dissimilarity_method}: As input;
\code{center_method}: As input;
\code{optimizer_method}: As input.
}
\description{
K-mean alignment and variants for functional data
}
\examples{
res <- kma(
  simulated30$x,
  simulated30$y,
  seeds = c(1, 21),
  n_clust = 2,
  center_method = "medoid",
  warping_method = "affine",
  dissimilarity_method = "pearson"
)
}
